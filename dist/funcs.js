// Generated by LiveScript 1.3.0
'use strict';
var _hasOwnProperty, curry, apply, applyTo, flip, chain, tryCatch, slice$ = [].slice, out$ = typeof exports != 'undefined' && exports || this;
_hasOwnProperty = Object.prototype.hasOwnProperty;
function cloneArray(xs){
  var i$, len$, x, results$ = [];
  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
    x = xs[i$];
    results$.push(x);
  }
  return results$;
}
function reverseArray(xs){
  var result, i, len;
  result = [];
  i = 0;
  len = xs.length;
  while (len !== 0) {
    result[--len] = xs[i++];
  }
  return result;
}
function mixin(dest){
  var sources, i$, len$, src, key, val;
  dest == null && (dest = {});
  sources = slice$.call(arguments, 1);
  for (i$ = 0, len$ = sources.length; i$ < len$; ++i$) {
    src = sources[i$];
    for (key in src) {
      val = src[key];
      dest[key] = val;
    }
  }
  return dest;
}
out$.curry = curry = function(n, fn){
  var _curry;
  if (typeof n === 'function') {
    fn = n;
    n = fn.length;
  }
  _curry = function(args){
    if (!(n > 1)) {
      return fn;
    } else {
      return function(){
        var params;
        params = cloneArray(args);
        if (params.push.apply(params, arguments) < n && arguments.length) {
          return _curry(params);
        } else {
          return apply(fn, params);
        }
      };
    }
  };
  return _curry([]);
};
out$.apply = apply = function(f, xs){
  switch (xs.length) {
  case 0:
    return f();
  case 1:
    return f(xs[0]);
  case 2:
    return f(xs[0], xs[1]);
  case 3:
    return f(xs[0], xs[1], xs[2]);
  case 4:
    return f(xs[0], xs[1], xs[2], xs[3]);
  case 5:
    return f(xs[0], xs[1], xs[2], xs[3], xs[4]);
  case 6:
    return f(xs[0], xs[1], xs[2], xs[3], xs[4], xs[5]);
  case 7:
    return f(xs[0], xs[1], xs[2], xs[3], xs[4], xs[5], xs[6]);
  case 8:
    return f(xs[0], xs[1], xs[2], xs[3], xs[4], xs[5], xs[6], xs[7]);
  case 9:
    return f(xs[0], xs[1], xs[2], xs[3], xs[4], xs[5], xs[6], xs[7], xs[8]);
  default:
    return f.apply(void 8, xs);
  }
};
out$.applyTo = applyTo = function(ctx, f, xs){
  switch (xs.length) {
  case 0:
    return f.call(ctx);
  case 1:
    return f.call(ctx, xs[0]);
  case 2:
    return f.call(ctx, xs[0], xs[1]);
  case 3:
    return f.call(ctx, xs[0], xs[1], xs[2]);
  case 4:
    return f.call(ctx, xs[0], xs[1], xs[2], xs[3]);
  case 5:
    return f.call(ctx, xs[0], xs[1], xs[2], xs[3], xs[4]);
  case 6:
    return f.call(ctx, xs[0], xs[1], xs[2], xs[3], xs[4], xs[5]);
  case 7:
    return f.call(ctx, xs[0], xs[1], xs[2], xs[3], xs[4], xs[5], xs[6]);
  case 8:
    return f.call(ctx, xs[0], xs[1], xs[2], xs[3], xs[4], xs[5], xs[6], xs[7]);
  case 9:
    return f.call(ctx, xs[0], xs[1], xs[2], xs[3], xs[4], xs[5], xs[6], xs[7], xs[8]);
  default:
    return f.apply(ctx, xs);
  }
};
out$.flip = flip = curry(2, function(f){
  var xs;
  xs = slice$.call(arguments, 1);
  return applyNoContext(f, reverseArray(xs));
});
out$.chain = chain = function(){
  var i$, fns, cb, link, e;
  fns = 0 < (i$ = arguments.length - 1) ? slice$.call(arguments, 0, i$) : (i$ = 0, []), cb = arguments[i$];
  link = function(e){
    var args;
    args = slice$.call(arguments, 1);
    if (e || fns.length === 0) {
      cb.apply(null, arguments);
    } else {
      try {
        applyNoContext(fns.shift(), args.concat(link));
      } catch (e$) {
        e = e$;
        cb(e);
      }
    }
  };
  try {
    fns.shift()(link);
  } catch (e$) {
    e = e$;
    cb(e);
  }
};
out$.tryCatch = tryCatch = function(fn, cb){
  var err, res, e;
  err = null;
  res = null;
  try {
    res = fn();
  } catch (e$) {
    e = e$;
    err = e instanceof Error
      ? e
      : new Error(e);
  }
  if (cb) {
    cb(err, res);
  }
  err || res;
};
function Base(){}
if (typeof Object.create === 'function') {
  Base.prototype = Object.create(null);
}
Base.extend = function(proto, props){
  var parent, child, Surrogate;
  parent = this;
  child = proto && _hasOwnProperty.call(proto, 'constructor')
    ? proto.constructor
    : function(){
      return applyTo(this, parent, arguments);
    };
  mixin(child, parent, props);
  Surrogate = function(){
    return this.constructor = child;
  };
  Surrogate.prototype = parent.prototype;
  child.prototype = new Surrogate;
  if (proto) {
    mixin(child.prototype, proto);
  }
  return child;
};
out$.Base = Base;